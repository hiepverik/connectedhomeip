/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <app-common/zap-generated/cluster-enums.h>

namespace chip {
namespace app {
namespace Clusters {

namespace PowerConfiguration {

CHIP_ERROR CheckBatterySize(BatterySize val)
{
    switch (val)
    {
    case BatterySize::kNoBattery:
    case BatterySize::kBuiltIn:
    case BatterySize::kOther:
    case BatterySize::kAa:
    case BatterySize::kAaa:
    case BatterySize::kC:
    case BatterySize::kD:
    case BatterySize::kUnknown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace PowerConfiguration

namespace DeviceTemperatureConfiguration {
} // namespace DeviceTemperatureConfiguration

namespace Identify {

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckIdentifyEffectIdentifier(IdentifyEffectIdentifier val)
{
    switch (val)
    {
    case IdentifyEffectIdentifier::kBlink:
    case IdentifyEffectIdentifier::kBreathe:
    case IdentifyEffectIdentifier::kOkay:
    case IdentifyEffectIdentifier::kChannelChange:
    case IdentifyEffectIdentifier::kFinishEffect:
    case IdentifyEffectIdentifier::kStopEffect:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckIdentifyEffectVariant(IdentifyEffectVariant val)
{
    switch (val)
    {
    case IdentifyEffectVariant::kDefault:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckIdentifyIdentifyType(IdentifyIdentifyType val)
{
    switch (val)
    {
    case IdentifyIdentifyType::kNone:
    case IdentifyIdentifyType::kVisibleLight:
    case IdentifyIdentifyType::kVisibleLED:
    case IdentifyIdentifyType::kAudibleBeep:
    case IdentifyIdentifyType::kDisplay:
    case IdentifyIdentifyType::kActuator:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif
} // namespace Identify

namespace Groups {
} // namespace Groups

namespace Scenes {
} // namespace Scenes

namespace OnOff {

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckOnOffDelayedAllOffEffectVariant(OnOffDelayedAllOffEffectVariant val)
{
    switch (val)
    {
    case OnOffDelayedAllOffEffectVariant::kFadeToOffIn0p8Seconds:
    case OnOffDelayedAllOffEffectVariant::kNoFade:
    case OnOffDelayedAllOffEffectVariant::k50PercentDimDownIn0p8SecondsThenFadeToOffIn12Seconds:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckOnOffDyingLightEffectVariant(OnOffDyingLightEffectVariant val)
{
    switch (val)
    {
    case OnOffDyingLightEffectVariant::k20PercenterDimUpIn0p5SecondsThenFadeToOffIn1Second:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckOnOffEffectIdentifier(OnOffEffectIdentifier val)
{
    switch (val)
    {
    case OnOffEffectIdentifier::kDelayedAllOff:
    case OnOffEffectIdentifier::kDyingLight:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

CHIP_ERROR CheckOnOffStartUpOnOff(OnOffStartUpOnOff val)
{
    switch (val)
    {
    case OnOffStartUpOnOff::kOff:
    case OnOffStartUpOnOff::kOn:
    case OnOffStartUpOnOff::kTogglePreviousOnOff:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace OnOff

namespace OnOffSwitchConfiguration {

CHIP_ERROR CheckSwitchActions(SwitchActions val)
{
    switch (val)
    {
    case SwitchActions::kOn:
    case SwitchActions::kOff:
    case SwitchActions::kToggle:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckSwitchType(SwitchType val)
{
    switch (val)
    {
    case SwitchType::kToggle:
    case SwitchType::kMomentary:
    case SwitchType::kMultiFunction:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace OnOffSwitchConfiguration

namespace LevelControl {

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckMoveMode(MoveMode val)
{
    switch (val)
    {
    case MoveMode::kUp:
    case MoveMode::kDown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckStepMode(StepMode val)
{
    switch (val)
    {
    case StepMode::kUp:
    case StepMode::kDown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif
} // namespace LevelControl

namespace Alarms {
} // namespace Alarms

namespace Time {
} // namespace Time

namespace BinaryInputBasic {
} // namespace BinaryInputBasic

namespace PowerProfile {
} // namespace PowerProfile

namespace ApplianceControl {

CHIP_ERROR CheckApplianceStatus(ApplianceStatus val)
{
    switch (val)
    {
    case ApplianceStatus::kOff:
    case ApplianceStatus::kStandBy:
    case ApplianceStatus::kProgrammed:
    case ApplianceStatus::kProgrammedWaitingToStart:
    case ApplianceStatus::kRunning:
    case ApplianceStatus::kPause:
    case ApplianceStatus::kEndProgrammed:
    case ApplianceStatus::kFailure:
    case ApplianceStatus::kProgrammeInterrupted:
    case ApplianceStatus::kIdle:
    case ApplianceStatus::kRinseHold:
    case ApplianceStatus::kService:
    case ApplianceStatus::kSuperfreezing:
    case ApplianceStatus::kSupercooling:
    case ApplianceStatus::kSuperheating:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckCommandIdentification(CommandIdentification val)
{
    switch (val)
    {
    case CommandIdentification::kStart:
    case CommandIdentification::kStop:
    case CommandIdentification::kPause:
    case CommandIdentification::kStartSuperfreezing:
    case CommandIdentification::kStopSuperfreezing:
    case CommandIdentification::kStartSupercooling:
    case CommandIdentification::kStopSupercooling:
    case CommandIdentification::kDisableGas:
    case CommandIdentification::kEnableGas:
    case CommandIdentification::kEnableEnergyControl:
    case CommandIdentification::kDisableEnergyControl:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckWarningEvent(WarningEvent val)
{
    switch (val)
    {
    case WarningEvent::kWarning1OverallPowerAboveAvailablePowerLevel:
    case WarningEvent::kWarning2OverallPowerAbovePowerThresholdLevel:
    case WarningEvent::kWarning3OverallPowerBackBelowTheAvailablePowerLevel:
    case WarningEvent::kWarning4OverallPowerBackBelowThePowerThresholdLevel:
    case WarningEvent::kWarning5OverallPowerWillBePotentiallyAboveAvailablePowerLevelIfTheApplianceStarts:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace ApplianceControl

namespace PulseWidthModulation {
} // namespace PulseWidthModulation

namespace Descriptor {
} // namespace Descriptor

namespace Binding {
} // namespace Binding

namespace AccessControl {

CHIP_ERROR CheckAuthMode(AuthMode val)
{
    switch (val)
    {
    case AuthMode::kPase:
    case AuthMode::kCase:
    case AuthMode::kGroup:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckChangeTypeEnum(ChangeTypeEnum val)
{
    switch (val)
    {
    case ChangeTypeEnum::kChanged:
    case ChangeTypeEnum::kAdded:
    case ChangeTypeEnum::kRemoved:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckPrivilege(Privilege val)
{
    switch (val)
    {
    case Privilege::kView:
    case Privilege::kProxyView:
    case Privilege::kOperate:
    case Privilege::kManage:
    case Privilege::kAdminister:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace AccessControl

namespace PollControl {
} // namespace PollControl

namespace BridgedActions {

CHIP_ERROR CheckActionErrorEnum(ActionErrorEnum val)
{
    switch (val)
    {
    case ActionErrorEnum::kUnknown:
    case ActionErrorEnum::kInterrupted:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckActionStateEnum(ActionStateEnum val)
{
    switch (val)
    {
    case ActionStateEnum::kInactive:
    case ActionStateEnum::kActive:
    case ActionStateEnum::kPaused:
    case ActionStateEnum::kDisabled:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckActionTypeEnum(ActionTypeEnum val)
{
    switch (val)
    {
    case ActionTypeEnum::kOther:
    case ActionTypeEnum::kScene:
    case ActionTypeEnum::kSequence:
    case ActionTypeEnum::kAutomation:
    case ActionTypeEnum::kException:
    case ActionTypeEnum::kNotification:
    case ActionTypeEnum::kAlarm:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckEndpointListTypeEnum(EndpointListTypeEnum val)
{
    switch (val)
    {
    case EndpointListTypeEnum::kOther:
    case EndpointListTypeEnum::kRoom:
    case EndpointListTypeEnum::kZone:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace BridgedActions

namespace Basic {
} // namespace Basic

namespace OtaSoftwareUpdateProvider {

CHIP_ERROR CheckOTAApplyUpdateAction(OTAApplyUpdateAction val)
{
    switch (val)
    {
    case OTAApplyUpdateAction::kProceed:
    case OTAApplyUpdateAction::kAwaitNextAction:
    case OTAApplyUpdateAction::kDiscontinue:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckOTADownloadProtocol(OTADownloadProtocol val)
{
    switch (val)
    {
    case OTADownloadProtocol::kBDXSynchronous:
    case OTADownloadProtocol::kBDXAsynchronous:
    case OTADownloadProtocol::kHttps:
    case OTADownloadProtocol::kVendorSpecific:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckOTAQueryStatus(OTAQueryStatus val)
{
    switch (val)
    {
    case OTAQueryStatus::kUpdateAvailable:
    case OTAQueryStatus::kBusy:
    case OTAQueryStatus::kNotAvailable:
    case OTAQueryStatus::kDownloadProtocolNotSupported:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace OtaSoftwareUpdateProvider

namespace OtaSoftwareUpdateRequestor {

CHIP_ERROR CheckOTAAnnouncementReason(OTAAnnouncementReason val)
{
    switch (val)
    {
    case OTAAnnouncementReason::kSimpleAnnouncement:
    case OTAAnnouncementReason::kUpdateAvailable:
    case OTAAnnouncementReason::kUrgentUpdateAvailable:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckOTAChangeReasonEnum(OTAChangeReasonEnum val)
{
    switch (val)
    {
    case OTAChangeReasonEnum::kUnknown:
    case OTAChangeReasonEnum::kSuccess:
    case OTAChangeReasonEnum::kFailure:
    case OTAChangeReasonEnum::kTimeOut:
    case OTAChangeReasonEnum::kDelayByProvider:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckOTAUpdateStateEnum(OTAUpdateStateEnum val)
{
    switch (val)
    {
    case OTAUpdateStateEnum::kUnknown:
    case OTAUpdateStateEnum::kIdle:
    case OTAUpdateStateEnum::kQuerying:
    case OTAUpdateStateEnum::kDelayedOnQuery:
    case OTAUpdateStateEnum::kDownloading:
    case OTAUpdateStateEnum::kApplying:
    case OTAUpdateStateEnum::kDelayedOnApply:
    case OTAUpdateStateEnum::kRollingBack:
    case OTAUpdateStateEnum::kDelayedOnUserConsent:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace OtaSoftwareUpdateRequestor

namespace LocalizationConfiguration {
} // namespace LocalizationConfiguration

namespace TimeFormatLocalization {

CHIP_ERROR CheckCalendarType(CalendarType val)
{
    switch (val)
    {
    case CalendarType::kBuddhist:
    case CalendarType::kChinese:
    case CalendarType::kCoptic:
    case CalendarType::kEthiopian:
    case CalendarType::kGregorian:
    case CalendarType::kHebrew:
    case CalendarType::kIndian:
    case CalendarType::kIslamic:
    case CalendarType::kJapanese:
    case CalendarType::kKorean:
    case CalendarType::kPersian:
    case CalendarType::kTaiwanese:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckHourFormat(HourFormat val)
{
    switch (val)
    {
    case HourFormat::k12hr:
    case HourFormat::k24hr:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace TimeFormatLocalization

namespace UnitLocalization {

CHIP_ERROR CheckTempUnit(TempUnit val)
{
    switch (val)
    {
    case TempUnit::kFahrenheit:
    case TempUnit::kCelsius:
    case TempUnit::kKelvin:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace UnitLocalization

namespace PowerSourceConfiguration {
} // namespace PowerSourceConfiguration

namespace PowerSource {

CHIP_ERROR CheckBatChargeFaultType(BatChargeFaultType val)
{
    switch (val)
    {
    case BatChargeFaultType::kUnspecfied:
    case BatChargeFaultType::kAmbientTooHot:
    case BatChargeFaultType::kAmbientTooCold:
    case BatChargeFaultType::kBatteryTooHot:
    case BatChargeFaultType::kBatteryTooCold:
    case BatChargeFaultType::kBatteryAbsent:
    case BatChargeFaultType::kBatteryOverVoltage:
    case BatChargeFaultType::kBatteryUnderVoltage:
    case BatChargeFaultType::kChargerOverVoltage:
    case BatChargeFaultType::kChargerUnderVoltage:
    case BatChargeFaultType::kSafetyTimeout:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckBatFaultType(BatFaultType val)
{
    switch (val)
    {
    case BatFaultType::kUnspecfied:
    case BatFaultType::kOverTemp:
    case BatFaultType::kUnderTemp:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckBatteryChargeLevel(BatteryChargeLevel val)
{
    switch (val)
    {
    case BatteryChargeLevel::kOk:
    case BatteryChargeLevel::kWarning:
    case BatteryChargeLevel::kCritical:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckBatteryChargeState(BatteryChargeState val)
{
    switch (val)
    {
    case BatteryChargeState::kUnknown:
    case BatteryChargeState::kIsCharging:
    case BatteryChargeState::kIsAtFullCharge:
    case BatteryChargeState::kIsNotCharging:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckBatteryReplaceability(BatteryReplaceability val)
{
    switch (val)
    {
    case BatteryReplaceability::kUnspecified:
    case BatteryReplaceability::kNotReplaceable:
    case BatteryReplaceability::kUserReplaceable:
    case BatteryReplaceability::kFactoryReplaceable:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckPowerSourceStatus(PowerSourceStatus val)
{
    switch (val)
    {
    case PowerSourceStatus::kUnspecfied:
    case PowerSourceStatus::kActive:
    case PowerSourceStatus::kStandby:
    case PowerSourceStatus::kUnavailable:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckWiredCurrentType(WiredCurrentType val)
{
    switch (val)
    {
    case WiredCurrentType::kAc:
    case WiredCurrentType::kDc:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckWiredFaultType(WiredFaultType val)
{
    switch (val)
    {
    case WiredFaultType::kUnspecfied:
    case WiredFaultType::kOverVoltage:
    case WiredFaultType::kUnderVoltage:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace PowerSource

namespace GeneralCommissioning {

CHIP_ERROR CheckCommissioningError(CommissioningError val)
{
    switch (val)
    {
    case CommissioningError::kOk:
    case CommissioningError::kValueOutsideRange:
    case CommissioningError::kInvalidAuthentication:
    case CommissioningError::kNoFailSafe:
    case CommissioningError::kBusyWithOtherAdmin:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckRegulatoryLocationType(RegulatoryLocationType val)
{
    switch (val)
    {
    case RegulatoryLocationType::kIndoor:
    case RegulatoryLocationType::kOutdoor:
    case RegulatoryLocationType::kIndoorOutdoor:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace GeneralCommissioning

namespace NetworkCommissioning {

CHIP_ERROR CheckNetworkCommissioningStatus(NetworkCommissioningStatus val)
{
    switch (val)
    {
    case NetworkCommissioningStatus::kSuccess:
    case NetworkCommissioningStatus::kOutOfRange:
    case NetworkCommissioningStatus::kBoundsExceeded:
    case NetworkCommissioningStatus::kNetworkIDNotFound:
    case NetworkCommissioningStatus::kDuplicateNetworkID:
    case NetworkCommissioningStatus::kNetworkNotFound:
    case NetworkCommissioningStatus::kRegulatoryError:
    case NetworkCommissioningStatus::kAuthFailure:
    case NetworkCommissioningStatus::kUnsupportedSecurity:
    case NetworkCommissioningStatus::kOtherConnectionFailure:
    case NetworkCommissioningStatus::kIPV6Failed:
    case NetworkCommissioningStatus::kIPBindFailed:
    case NetworkCommissioningStatus::kUnknownError:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckWiFiBand(WiFiBand val)
{
    switch (val)
    {
    case WiFiBand::k2g4:
    case WiFiBand::k3g65:
    case WiFiBand::k5g:
    case WiFiBand::k6g:
    case WiFiBand::k60g:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace NetworkCommissioning

namespace DiagnosticLogs {

CHIP_ERROR CheckLogsIntent(LogsIntent val)
{
    switch (val)
    {
    case LogsIntent::kEndUserSupport:
    case LogsIntent::kNetworkDiag:
    case LogsIntent::kCrashLogs:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckLogsStatus(LogsStatus val)
{
    switch (val)
    {
    case LogsStatus::kSuccess:
    case LogsStatus::kExhausted:
    case LogsStatus::kNoLogs:
    case LogsStatus::kBusy:
    case LogsStatus::kDenied:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckLogsTransferProtocol(LogsTransferProtocol val)
{
    switch (val)
    {
    case LogsTransferProtocol::kResponsePayload:
    case LogsTransferProtocol::kBdx:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace DiagnosticLogs

namespace GeneralDiagnostics {

CHIP_ERROR CheckBootReasonType(BootReasonType val)
{
    switch (val)
    {
    case BootReasonType::kUnspecified:
    case BootReasonType::kPowerOnReboot:
    case BootReasonType::kBrownOutReset:
    case BootReasonType::kSoftwareWatchdogReset:
    case BootReasonType::kHardwareWatchdogReset:
    case BootReasonType::kSoftwareUpdateCompleted:
    case BootReasonType::kSoftwareReset:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckHardwareFaultType(HardwareFaultType val)
{
    switch (val)
    {
    case HardwareFaultType::kUnspecified:
    case HardwareFaultType::kRadio:
    case HardwareFaultType::kSensor:
    case HardwareFaultType::kResettableOverTemp:
    case HardwareFaultType::kNonResettableOverTemp:
    case HardwareFaultType::kPowerSource:
    case HardwareFaultType::kVisualDisplayFault:
    case HardwareFaultType::kAudioOutputFault:
    case HardwareFaultType::kUserInterfaceFault:
    case HardwareFaultType::kNonVolatileMemoryError:
    case HardwareFaultType::kTamperDetected:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckInterfaceType(InterfaceType val)
{
    switch (val)
    {
    case InterfaceType::kUnspecified:
    case InterfaceType::kWiFi:
    case InterfaceType::kEthernet:
    case InterfaceType::kCellular:
    case InterfaceType::kThread:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckNetworkFaultType(NetworkFaultType val)
{
    switch (val)
    {
    case NetworkFaultType::kUnspecified:
    case NetworkFaultType::kHardwareFailure:
    case NetworkFaultType::kNetworkJammed:
    case NetworkFaultType::kConnectionFailed:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckRadioFaultType(RadioFaultType val)
{
    switch (val)
    {
    case RadioFaultType::kUnspecified:
    case RadioFaultType::kWiFiFault:
    case RadioFaultType::kCellularFault:
    case RadioFaultType::kThreadFault:
    case RadioFaultType::kNFCFault:
    case RadioFaultType::kBLEFault:
    case RadioFaultType::kEthernetFault:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif
} // namespace GeneralDiagnostics

namespace SoftwareDiagnostics {
} // namespace SoftwareDiagnostics

namespace ThreadNetworkDiagnostics {

CHIP_ERROR CheckNetworkFault(NetworkFault val)
{
    switch (val)
    {
    case NetworkFault::kUnspecified:
    case NetworkFault::kLinkDown:
    case NetworkFault::kHardwareFailure:
    case NetworkFault::kNetworkJammed:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckRoutingRole(RoutingRole val)
{
    switch (val)
    {
    case RoutingRole::kUnspecified:
    case RoutingRole::kUnassigned:
    case RoutingRole::kSleepyEndDevice:
    case RoutingRole::kEndDevice:
    case RoutingRole::kReed:
    case RoutingRole::kRouter:
    case RoutingRole::kLeader:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

CHIP_ERROR CheckThreadConnectionStatus(ThreadConnectionStatus val)
{
    switch (val)
    {
    case ThreadConnectionStatus::kConnected:
    case ThreadConnectionStatus::kNotConnected:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace ThreadNetworkDiagnostics

namespace WiFiNetworkDiagnostics {

CHIP_ERROR CheckAssociationFailureCause(AssociationFailureCause val)
{
    switch (val)
    {
    case AssociationFailureCause::kUnknown:
    case AssociationFailureCause::kAssociationFailed:
    case AssociationFailureCause::kAuthenticationFailed:
    case AssociationFailureCause::kSsidNotFound:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckSecurityType(SecurityType val)
{
    switch (val)
    {
    case SecurityType::kUnspecified:
    case SecurityType::kNone:
    case SecurityType::kWep:
    case SecurityType::kWpa:
    case SecurityType::kWpa2:
    case SecurityType::kWpa3:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

CHIP_ERROR CheckWiFiConnectionStatus(WiFiConnectionStatus val)
{
    switch (val)
    {
    case WiFiConnectionStatus::kConnected:
    case WiFiConnectionStatus::kNotConnected:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckWiFiVersionType(WiFiVersionType val)
{
    switch (val)
    {
    case WiFiVersionType::k80211a:
    case WiFiVersionType::k80211b:
    case WiFiVersionType::k80211g:
    case WiFiVersionType::k80211n:
    case WiFiVersionType::k80211ac:
    case WiFiVersionType::k80211ax:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif
} // namespace WiFiNetworkDiagnostics

namespace EthernetNetworkDiagnostics {

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckPHYRateType(PHYRateType val)
{
    switch (val)
    {
    case PHYRateType::k10m:
    case PHYRateType::k100m:
    case PHYRateType::k1000m:
    case PHYRateType::k25g:
    case PHYRateType::k5g:
    case PHYRateType::k10g:
    case PHYRateType::k40g:
    case PHYRateType::k100g:
    case PHYRateType::k200g:
    case PHYRateType::k400g:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif
} // namespace EthernetNetworkDiagnostics

namespace TimeSynchronization {
} // namespace TimeSynchronization

namespace BridgedDeviceBasic {
} // namespace BridgedDeviceBasic

namespace Switch {
} // namespace Switch

namespace AdministratorCommissioning {

CHIP_ERROR CheckCommissioningWindowStatus(CommissioningWindowStatus val)
{
    switch (val)
    {
    case CommissioningWindowStatus::kWindowNotOpen:
    case CommissioningWindowStatus::kEnhancedWindowOpen:
    case CommissioningWindowStatus::kBasicWindowOpen:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckStatusCode(StatusCode val)
{
    switch (val)
    {
    case StatusCode::kBusy:
    case StatusCode::kPAKEParameterError:
    case StatusCode::kWindowNotOpen:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif
} // namespace AdministratorCommissioning

namespace OperationalCredentials {

CHIP_ERROR CheckOperationalCertStatus(OperationalCertStatus val)
{
    switch (val)
    {
    case OperationalCertStatus::kSuccess:
    case OperationalCertStatus::kInvalidPublicKey:
    case OperationalCertStatus::kInvalidNodeOpId:
    case OperationalCertStatus::kInvalidNOC:
    case OperationalCertStatus::kMissingCsr:
    case OperationalCertStatus::kTableFull:
    case OperationalCertStatus::kInvalidAdminSubject:
    case OperationalCertStatus::kInsufficientPrivilege:
    case OperationalCertStatus::kFabricConflict:
    case OperationalCertStatus::kLabelConflict:
    case OperationalCertStatus::kInvalidFabricIndex:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace OperationalCredentials

namespace GroupKeyManagement {

CHIP_ERROR CheckGroupKeySecurityPolicy(GroupKeySecurityPolicy val)
{
    switch (val)
    {
    case GroupKeySecurityPolicy::kTrustFirst:
    case GroupKeySecurityPolicy::kCacheAndSync:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace GroupKeyManagement

namespace FixedLabel {
} // namespace FixedLabel

namespace UserLabel {
} // namespace UserLabel

namespace ProxyConfiguration {
} // namespace ProxyConfiguration

namespace ProxyDiscovery {
} // namespace ProxyDiscovery

namespace ProxyValid {
} // namespace ProxyValid

namespace BooleanState {
} // namespace BooleanState

namespace ModeSelect {
} // namespace ModeSelect

namespace ShadeConfiguration {
} // namespace ShadeConfiguration

namespace DoorLock {

CHIP_ERROR CheckDlAlarmCode(DlAlarmCode val)
{
    switch (val)
    {
    case DlAlarmCode::kLockJammed:
    case DlAlarmCode::kLockFactoryReset:
    case DlAlarmCode::kLockRadioPowerCycled:
    case DlAlarmCode::kWrongCodeEntryLimit:
    case DlAlarmCode::kFrontEsceutcheonRemoved:
    case DlAlarmCode::kDoorForcedOpen:
    case DlAlarmCode::kDoorAjar:
    case DlAlarmCode::kForcedUser:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlCredentialRule(DlCredentialRule val)
{
    switch (val)
    {
    case DlCredentialRule::kSingle:
    case DlCredentialRule::kDouble:
    case DlCredentialRule::kTri:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlCredentialType(DlCredentialType val)
{
    switch (val)
    {
    case DlCredentialType::kProgrammingPIN:
    case DlCredentialType::kPin:
    case DlCredentialType::kRfid:
    case DlCredentialType::kFingerprint:
    case DlCredentialType::kFingerVein:
    case DlCredentialType::kFace:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlDataOperationType(DlDataOperationType val)
{
    switch (val)
    {
    case DlDataOperationType::kAdd:
    case DlDataOperationType::kClear:
    case DlDataOperationType::kModify:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlDoorState(DlDoorState val)
{
    switch (val)
    {
    case DlDoorState::kDoorOpen:
    case DlDoorState::kDoorClosed:
    case DlDoorState::kDoorJammed:
    case DlDoorState::kDoorForcedOpen:
    case DlDoorState::kDoorUnspecifiedError:
    case DlDoorState::kDoorAjar:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlLockDataType(DlLockDataType val)
{
    switch (val)
    {
    case DlLockDataType::kUnspecified:
    case DlLockDataType::kProgrammingCode:
    case DlLockDataType::kUserIndex:
    case DlLockDataType::kWeekDaySchedule:
    case DlLockDataType::kYearDaySchedule:
    case DlLockDataType::kHolidaySchedule:
    case DlLockDataType::kPin:
    case DlLockDataType::kRfid:
    case DlLockDataType::kFingerprint:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlLockOperationType(DlLockOperationType val)
{
    switch (val)
    {
    case DlLockOperationType::kLock:
    case DlLockOperationType::kUnlock:
    case DlLockOperationType::kNonAccessUserEvent:
    case DlLockOperationType::kForcedUserEvent:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlLockState(DlLockState val)
{
    switch (val)
    {
    case DlLockState::kNotFullyLocked:
    case DlLockState::kLocked:
    case DlLockState::kUnlocked:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlLockType(DlLockType val)
{
    switch (val)
    {
    case DlLockType::kDeadBolt:
    case DlLockType::kMagnetic:
    case DlLockType::kOther:
    case DlLockType::kMortise:
    case DlLockType::kRim:
    case DlLockType::kLatchBolt:
    case DlLockType::kCylindricalLock:
    case DlLockType::kTubularLock:
    case DlLockType::kInterconnectedLock:
    case DlLockType::kDeadLatch:
    case DlLockType::kDoorFurniture:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlOperatingMode(DlOperatingMode val)
{
    switch (val)
    {
    case DlOperatingMode::kNormal:
    case DlOperatingMode::kVacation:
    case DlOperatingMode::kPrivacy:
    case DlOperatingMode::kNoRemoteLockUnlock:
    case DlOperatingMode::kPassage:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlOperationError(DlOperationError val)
{
    switch (val)
    {
    case DlOperationError::kUnspecified:
    case DlOperationError::kInvalidCredential:
    case DlOperationError::kDisabledUserDenied:
    case DlOperationError::kRestricted:
    case DlOperationError::kInsufficientBattery:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlOperationSource(DlOperationSource val)
{
    switch (val)
    {
    case DlOperationSource::kUnspecified:
    case DlOperationSource::kManual:
    case DlOperationSource::kProprietaryRemote:
    case DlOperationSource::kKeypad:
    case DlOperationSource::kAuto:
    case DlOperationSource::kButton:
    case DlOperationSource::kSchedule:
    case DlOperationSource::kRemote:
    case DlOperationSource::kRfid:
    case DlOperationSource::kBiometric:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlStatus(DlStatus val)
{
    switch (val)
    {
    case DlStatus::kSuccess:
    case DlStatus::kFailure:
    case DlStatus::kDuplicate:
    case DlStatus::kOccupied:
    case DlStatus::kInvalidField:
    case DlStatus::kResourceExhausted:
    case DlStatus::kNotFound:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlUserStatus(DlUserStatus val)
{
    switch (val)
    {
    case DlUserStatus::kAvailable:
    case DlUserStatus::kOccupiedEnabled:
    case DlUserStatus::kOccupiedDisabled:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDlUserType(DlUserType val)
{
    switch (val)
    {
    case DlUserType::kUnrestrictedUser:
    case DlUserType::kYearDayScheduleUser:
    case DlUserType::kWeekDayScheduleUser:
    case DlUserType::kProgrammingUser:
    case DlUserType::kNonAccessUser:
    case DlUserType::kForcedUser:
    case DlUserType::kDisposableUser:
    case DlUserType::kExpiringUser:
    case DlUserType::kScheduleRestrictedUser:
    case DlUserType::kRemoteOnlyUser:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDoorLockOperationEventCode(DoorLockOperationEventCode val)
{
    switch (val)
    {
    case DoorLockOperationEventCode::kUnknownOrMfgSpecific:
    case DoorLockOperationEventCode::kLock:
    case DoorLockOperationEventCode::kUnlock:
    case DoorLockOperationEventCode::kLockInvalidPinOrId:
    case DoorLockOperationEventCode::kLockInvalidSchedule:
    case DoorLockOperationEventCode::kUnlockInvalidPinOrId:
    case DoorLockOperationEventCode::kUnlockInvalidSchedule:
    case DoorLockOperationEventCode::kOneTouchLock:
    case DoorLockOperationEventCode::kKeyLock:
    case DoorLockOperationEventCode::kKeyUnlock:
    case DoorLockOperationEventCode::kAutoLock:
    case DoorLockOperationEventCode::kScheduleLock:
    case DoorLockOperationEventCode::kScheduleUnlock:
    case DoorLockOperationEventCode::kManualLock:
    case DoorLockOperationEventCode::kManualUnlock:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDoorLockProgrammingEventCode(DoorLockProgrammingEventCode val)
{
    switch (val)
    {
    case DoorLockProgrammingEventCode::kUnknownOrMfgSpecific:
    case DoorLockProgrammingEventCode::kMasterCodeChanged:
    case DoorLockProgrammingEventCode::kPinAdded:
    case DoorLockProgrammingEventCode::kPinDeleted:
    case DoorLockProgrammingEventCode::kPinChanged:
    case DoorLockProgrammingEventCode::kIdAdded:
    case DoorLockProgrammingEventCode::kIdDeleted:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDoorLockSetPinOrIdStatus(DoorLockSetPinOrIdStatus val)
{
    switch (val)
    {
    case DoorLockSetPinOrIdStatus::kSuccess:
    case DoorLockSetPinOrIdStatus::kGeneralFailure:
    case DoorLockSetPinOrIdStatus::kMemoryFull:
    case DoorLockSetPinOrIdStatus::kDuplicateCodeError:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDoorLockUserStatus(DoorLockUserStatus val)
{
    switch (val)
    {
    case DoorLockUserStatus::kAvailable:
    case DoorLockUserStatus::kOccupiedEnabled:
    case DoorLockUserStatus::kOccupiedDisabled:
    case DoorLockUserStatus::kNotSupported:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckDoorLockUserType(DoorLockUserType val)
{
    switch (val)
    {
    case DoorLockUserType::kUnrestricted:
    case DoorLockUserType::kYearDayScheduleUser:
    case DoorLockUserType::kWeekDayScheduleUser:
    case DoorLockUserType::kMasterUser:
    case DoorLockUserType::kNonAccessUser:
    case DoorLockUserType::kNotSupported:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace DoorLock

namespace WindowCovering {

CHIP_ERROR CheckEndProductType(EndProductType val)
{
    switch (val)
    {
    case EndProductType::kRollerShade:
    case EndProductType::kRomanShade:
    case EndProductType::kBalloonShade:
    case EndProductType::kWovenWood:
    case EndProductType::kPleatedShade:
    case EndProductType::kCellularShade:
    case EndProductType::kLayeredShade:
    case EndProductType::kLayeredShade2D:
    case EndProductType::kSheerShade:
    case EndProductType::kTiltOnlyInteriorBlind:
    case EndProductType::kInteriorBlind:
    case EndProductType::kVerticalBlindStripCurtain:
    case EndProductType::kInteriorVenetianBlind:
    case EndProductType::kExteriorVenetianBlind:
    case EndProductType::kLateralLeftCurtain:
    case EndProductType::kLateralRightCurtain:
    case EndProductType::kCentralCurtain:
    case EndProductType::kRollerShutter:
    case EndProductType::kExteriorVerticalScreen:
    case EndProductType::kAwningTerracePatio:
    case EndProductType::kAwningVerticalScreen:
    case EndProductType::kTiltOnlyPergola:
    case EndProductType::kSwingingShutter:
    case EndProductType::kSlidingShutter:
    case EndProductType::kUnknown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckType(Type val)
{
    switch (val)
    {
    case Type::kRollerShade:
    case Type::kRollerShade2Motor:
    case Type::kRollerShadeExterior:
    case Type::kRollerShadeExterior2Motor:
    case Type::kDrapery:
    case Type::kAwning:
    case Type::kShutter:
    case Type::kTiltBlindTiltOnly:
    case Type::kTiltBlindLiftAndTilt:
    case Type::kProjectorScreen:
    case Type::kUnknown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace WindowCovering

namespace BarrierControl {
} // namespace BarrierControl

namespace PumpConfigurationAndControl {

CHIP_ERROR CheckPumpControlMode(PumpControlMode val)
{
    switch (val)
    {
    case PumpControlMode::kConstantSpeed:
    case PumpControlMode::kConstantPressure:
    case PumpControlMode::kProportionalPressure:
    case PumpControlMode::kConstantFlow:
    case PumpControlMode::kConstantTemperature:
    case PumpControlMode::kAutomatic:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckPumpOperationMode(PumpOperationMode val)
{
    switch (val)
    {
    case PumpOperationMode::kNormal:
    case PumpOperationMode::kMinimum:
    case PumpOperationMode::kMaximum:
    case PumpOperationMode::kLocal:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace PumpConfigurationAndControl

namespace Thermostat {

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckSetpointAdjustMode(SetpointAdjustMode val)
{
    switch (val)
    {
    case SetpointAdjustMode::kHeatSetpoint:
    case SetpointAdjustMode::kCoolSetpoint:
    case SetpointAdjustMode::kHeatAndCoolSetpoints:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

CHIP_ERROR CheckThermostatControlSequence(ThermostatControlSequence val)
{
    switch (val)
    {
    case ThermostatControlSequence::kCoolingOnly:
    case ThermostatControlSequence::kCoolingWithReheat:
    case ThermostatControlSequence::kHeatingOnly:
    case ThermostatControlSequence::kHeatingWithReheat:
    case ThermostatControlSequence::kCoolingAndHeating:
    case ThermostatControlSequence::kCoolingAndHeatingWithReheat:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckThermostatRunningMode(ThermostatRunningMode val)
{
    switch (val)
    {
    case ThermostatRunningMode::kOff:
    case ThermostatRunningMode::kCool:
    case ThermostatRunningMode::kHeat:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckThermostatSystemMode(ThermostatSystemMode val)
{
    switch (val)
    {
    case ThermostatSystemMode::kOff:
    case ThermostatSystemMode::kAuto:
    case ThermostatSystemMode::kCool:
    case ThermostatSystemMode::kHeat:
    case ThermostatSystemMode::kEmergencyHeating:
    case ThermostatSystemMode::kPrecooling:
    case ThermostatSystemMode::kFanOnly:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace Thermostat

namespace FanControl {

CHIP_ERROR CheckFanModeSequenceType(FanModeSequenceType val)
{
    switch (val)
    {
    case FanModeSequenceType::kOffLowMedHigh:
    case FanModeSequenceType::kOffLowHigh:
    case FanModeSequenceType::kOffLowMedHighAuto:
    case FanModeSequenceType::kOffLowHighAuto:
    case FanModeSequenceType::kOffOnAuto:
    case FanModeSequenceType::kOffOn:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckFanModeType(FanModeType val)
{
    switch (val)
    {
    case FanModeType::kOff:
    case FanModeType::kLow:
    case FanModeType::kMedium:
    case FanModeType::kHigh:
    case FanModeType::kOn:
    case FanModeType::kAuto:
    case FanModeType::kSmart:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace FanControl

namespace DehumidificationControl {
} // namespace DehumidificationControl

namespace ThermostatUserInterfaceConfiguration {
} // namespace ThermostatUserInterfaceConfiguration

namespace ColorControl {

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckColorLoopAction(ColorLoopAction val)
{
    switch (val)
    {
    case ColorLoopAction::kDeactivate:
    case ColorLoopAction::kActivateFromColorLoopStartEnhancedHue:
    case ColorLoopAction::kActivateFromEnhancedCurrentHue:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckColorLoopDirection(ColorLoopDirection val)
{
    switch (val)
    {
    case ColorLoopDirection::kDecrementHue:
    case ColorLoopDirection::kIncrementHue:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckColorMode(ColorMode val)
{
    switch (val)
    {
    case ColorMode::kCurrentHueAndCurrentSaturation:
    case ColorMode::kCurrentXAndCurrentY:
    case ColorMode::kColorTemperature:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckHueDirection(HueDirection val)
{
    switch (val)
    {
    case HueDirection::kShortestDistance:
    case HueDirection::kLongestDistance:
    case HueDirection::kUp:
    case HueDirection::kDown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckHueMoveMode(HueMoveMode val)
{
    switch (val)
    {
    case HueMoveMode::kStop:
    case HueMoveMode::kUp:
    case HueMoveMode::kDown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckHueStepMode(HueStepMode val)
{
    switch (val)
    {
    case HueStepMode::kUp:
    case HueStepMode::kDown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckSaturationMoveMode(SaturationMoveMode val)
{
    switch (val)
    {
    case SaturationMoveMode::kStop:
    case SaturationMoveMode::kUp:
    case SaturationMoveMode::kDown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif

// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
CHIP_ERROR CheckSaturationStepMode(SaturationStepMode val)
{
    switch (val)
    {
    case SaturationStepMode::kUp:
    case SaturationStepMode::kDown:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
#endif
} // namespace ColorControl

namespace BallastConfiguration {
} // namespace BallastConfiguration

namespace IlluminanceMeasurement {

CHIP_ERROR CheckLightSensorType(LightSensorType val)
{
    switch (val)
    {
    case LightSensorType::kPhotodiode:
    case LightSensorType::kCmos:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace IlluminanceMeasurement

namespace TemperatureMeasurement {
} // namespace TemperatureMeasurement

namespace PressureMeasurement {
} // namespace PressureMeasurement

namespace FlowMeasurement {
} // namespace FlowMeasurement

namespace RelativeHumidityMeasurement {
} // namespace RelativeHumidityMeasurement

namespace OccupancySensing {
} // namespace OccupancySensing

namespace CarbonMonoxideConcentrationMeasurement {
} // namespace CarbonMonoxideConcentrationMeasurement

namespace CarbonDioxideConcentrationMeasurement {
} // namespace CarbonDioxideConcentrationMeasurement

namespace EthyleneConcentrationMeasurement {
} // namespace EthyleneConcentrationMeasurement

namespace EthyleneOxideConcentrationMeasurement {
} // namespace EthyleneOxideConcentrationMeasurement

namespace HydrogenConcentrationMeasurement {
} // namespace HydrogenConcentrationMeasurement

namespace HydrogenSulphideConcentrationMeasurement {
} // namespace HydrogenSulphideConcentrationMeasurement

namespace NitricOxideConcentrationMeasurement {
} // namespace NitricOxideConcentrationMeasurement

namespace NitrogenDioxideConcentrationMeasurement {
} // namespace NitrogenDioxideConcentrationMeasurement

namespace OxygenConcentrationMeasurement {
} // namespace OxygenConcentrationMeasurement

namespace OzoneConcentrationMeasurement {
} // namespace OzoneConcentrationMeasurement

namespace SulfurDioxideConcentrationMeasurement {
} // namespace SulfurDioxideConcentrationMeasurement

namespace DissolvedOxygenConcentrationMeasurement {
} // namespace DissolvedOxygenConcentrationMeasurement

namespace BromateConcentrationMeasurement {
} // namespace BromateConcentrationMeasurement

namespace ChloraminesConcentrationMeasurement {
} // namespace ChloraminesConcentrationMeasurement

namespace ChlorineConcentrationMeasurement {
} // namespace ChlorineConcentrationMeasurement

namespace FecalColiformAndEColiConcentrationMeasurement {
} // namespace FecalColiformAndEColiConcentrationMeasurement

namespace FluorideConcentrationMeasurement {
} // namespace FluorideConcentrationMeasurement

namespace HaloaceticAcidsConcentrationMeasurement {
} // namespace HaloaceticAcidsConcentrationMeasurement

namespace TotalTrihalomethanesConcentrationMeasurement {
} // namespace TotalTrihalomethanesConcentrationMeasurement

namespace TotalColiformBacteriaConcentrationMeasurement {
} // namespace TotalColiformBacteriaConcentrationMeasurement

namespace TurbidityConcentrationMeasurement {
} // namespace TurbidityConcentrationMeasurement

namespace CopperConcentrationMeasurement {
} // namespace CopperConcentrationMeasurement

namespace LeadConcentrationMeasurement {
} // namespace LeadConcentrationMeasurement

namespace ManganeseConcentrationMeasurement {
} // namespace ManganeseConcentrationMeasurement

namespace SulfateConcentrationMeasurement {
} // namespace SulfateConcentrationMeasurement

namespace BromodichloromethaneConcentrationMeasurement {
} // namespace BromodichloromethaneConcentrationMeasurement

namespace BromoformConcentrationMeasurement {
} // namespace BromoformConcentrationMeasurement

namespace ChlorodibromomethaneConcentrationMeasurement {
} // namespace ChlorodibromomethaneConcentrationMeasurement

namespace ChloroformConcentrationMeasurement {
} // namespace ChloroformConcentrationMeasurement

namespace SodiumConcentrationMeasurement {
} // namespace SodiumConcentrationMeasurement

namespace WakeOnLan {
} // namespace WakeOnLan

namespace Channel {

CHIP_ERROR CheckChannelStatusEnum(ChannelStatusEnum val)
{
    switch (val)
    {
    case ChannelStatusEnum::kSuccess:
    case ChannelStatusEnum::kMultipleMatches:
    case ChannelStatusEnum::kNoMatches:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckLineupInfoTypeEnum(LineupInfoTypeEnum val)
{
    switch (val)
    {
    case LineupInfoTypeEnum::kMso:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace Channel

namespace TargetNavigator {

CHIP_ERROR CheckTargetNavigatorStatusEnum(TargetNavigatorStatusEnum val)
{
    switch (val)
    {
    case TargetNavigatorStatusEnum::kSuccess:
    case TargetNavigatorStatusEnum::kTargetNotFound:
    case TargetNavigatorStatusEnum::kNotAllowed:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace TargetNavigator

namespace MediaPlayback {

CHIP_ERROR CheckMediaPlaybackStatusEnum(MediaPlaybackStatusEnum val)
{
    switch (val)
    {
    case MediaPlaybackStatusEnum::kSuccess:
    case MediaPlaybackStatusEnum::kInvalidStateForCommand:
    case MediaPlaybackStatusEnum::kNotAllowed:
    case MediaPlaybackStatusEnum::kNotActive:
    case MediaPlaybackStatusEnum::kSpeedOutOfRange:
    case MediaPlaybackStatusEnum::kSeekOutOfRange:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckPlaybackStateEnum(PlaybackStateEnum val)
{
    switch (val)
    {
    case PlaybackStateEnum::kPlaying:
    case PlaybackStateEnum::kPaused:
    case PlaybackStateEnum::kNotPlaying:
    case PlaybackStateEnum::kBuffering:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace MediaPlayback

namespace MediaInput {

CHIP_ERROR CheckInputTypeEnum(InputTypeEnum val)
{
    switch (val)
    {
    case InputTypeEnum::kInternal:
    case InputTypeEnum::kAux:
    case InputTypeEnum::kCoax:
    case InputTypeEnum::kComposite:
    case InputTypeEnum::kHdmi:
    case InputTypeEnum::kInput:
    case InputTypeEnum::kLine:
    case InputTypeEnum::kOptical:
    case InputTypeEnum::kVideo:
    case InputTypeEnum::kScart:
    case InputTypeEnum::kUsb:
    case InputTypeEnum::kOther:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace MediaInput

namespace LowPower {
} // namespace LowPower

namespace KeypadInput {

CHIP_ERROR CheckCecKeyCode(CecKeyCode val)
{
    switch (val)
    {
    case CecKeyCode::kSelect:
    case CecKeyCode::kUp:
    case CecKeyCode::kDown:
    case CecKeyCode::kLeft:
    case CecKeyCode::kRight:
    case CecKeyCode::kRightUp:
    case CecKeyCode::kRightDown:
    case CecKeyCode::kLeftUp:
    case CecKeyCode::kLeftDown:
    case CecKeyCode::kRootMenu:
    case CecKeyCode::kSetupMenu:
    case CecKeyCode::kContentsMenu:
    case CecKeyCode::kFavoriteMenu:
    case CecKeyCode::kExit:
    case CecKeyCode::kMediaTopMenu:
    case CecKeyCode::kMediaContextSensitiveMenu:
    case CecKeyCode::kNumberEntryMode:
    case CecKeyCode::kNumber11:
    case CecKeyCode::kNumber12:
    case CecKeyCode::kNumber0OrNumber10:
    case CecKeyCode::kNumbers1:
    case CecKeyCode::kNumbers2:
    case CecKeyCode::kNumbers3:
    case CecKeyCode::kNumbers4:
    case CecKeyCode::kNumbers5:
    case CecKeyCode::kNumbers6:
    case CecKeyCode::kNumbers7:
    case CecKeyCode::kNumbers8:
    case CecKeyCode::kNumbers9:
    case CecKeyCode::kDot:
    case CecKeyCode::kEnter:
    case CecKeyCode::kClear:
    case CecKeyCode::kNextFavorite:
    case CecKeyCode::kChannelUp:
    case CecKeyCode::kChannelDown:
    case CecKeyCode::kPreviousChannel:
    case CecKeyCode::kSoundSelect:
    case CecKeyCode::kInputSelect:
    case CecKeyCode::kDisplayInformation:
    case CecKeyCode::kHelp:
    case CecKeyCode::kPageUp:
    case CecKeyCode::kPageDown:
    case CecKeyCode::kPower:
    case CecKeyCode::kVolumeUp:
    case CecKeyCode::kVolumeDown:
    case CecKeyCode::kMute:
    case CecKeyCode::kPlay:
    case CecKeyCode::kStop:
    case CecKeyCode::kPause:
    case CecKeyCode::kRecord:
    case CecKeyCode::kRewind:
    case CecKeyCode::kFastForward:
    case CecKeyCode::kEject:
    case CecKeyCode::kForward:
    case CecKeyCode::kBackward:
    case CecKeyCode::kStopRecord:
    case CecKeyCode::kPauseRecord:
    case CecKeyCode::kReserved:
    case CecKeyCode::kAngle:
    case CecKeyCode::kSubPicture:
    case CecKeyCode::kVideoOnDemand:
    case CecKeyCode::kElectronicProgramGuide:
    case CecKeyCode::kTimerProgramming:
    case CecKeyCode::kInitialConfiguration:
    case CecKeyCode::kSelectBroadcastType:
    case CecKeyCode::kSelectSoundPresentation:
    case CecKeyCode::kPlayFunction:
    case CecKeyCode::kPausePlayFunction:
    case CecKeyCode::kRecordFunction:
    case CecKeyCode::kPauseRecordFunction:
    case CecKeyCode::kStopFunction:
    case CecKeyCode::kMuteFunction:
    case CecKeyCode::kRestoreVolumeFunction:
    case CecKeyCode::kTuneFunction:
    case CecKeyCode::kSelectMediaFunction:
    case CecKeyCode::kSelectAvInputFunction:
    case CecKeyCode::kSelectAudioInputFunction:
    case CecKeyCode::kPowerToggleFunction:
    case CecKeyCode::kPowerOffFunction:
    case CecKeyCode::kPowerOnFunction:
    case CecKeyCode::kF1Blue:
    case CecKeyCode::kF2Red:
    case CecKeyCode::kF3Green:
    case CecKeyCode::kF4Yellow:
    case CecKeyCode::kF5:
    case CecKeyCode::kData:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckKeypadInputStatusEnum(KeypadInputStatusEnum val)
{
    switch (val)
    {
    case KeypadInputStatusEnum::kSuccess:
    case KeypadInputStatusEnum::kUnsupportedKey:
    case KeypadInputStatusEnum::kInvalidKeyInCurrentState:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace KeypadInput

namespace ContentLauncher {

CHIP_ERROR CheckContentLaunchStatusEnum(ContentLaunchStatusEnum val)
{
    switch (val)
    {
    case ContentLaunchStatusEnum::kSuccess:
    case ContentLaunchStatusEnum::kUrlNotAvailable:
    case ContentLaunchStatusEnum::kAuthFailed:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckMetricTypeEnum(MetricTypeEnum val)
{
    switch (val)
    {
    case MetricTypeEnum::kPixels:
    case MetricTypeEnum::kPercentage:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckParameterEnum(ParameterEnum val)
{
    switch (val)
    {
    case ParameterEnum::kActor:
    case ParameterEnum::kChannel:
    case ParameterEnum::kCharacter:
    case ParameterEnum::kDirector:
    case ParameterEnum::kEvent:
    case ParameterEnum::kFranchise:
    case ParameterEnum::kGenre:
    case ParameterEnum::kLeague:
    case ParameterEnum::kPopularity:
    case ParameterEnum::kProvider:
    case ParameterEnum::kSport:
    case ParameterEnum::kSportsTeam:
    case ParameterEnum::kType:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace ContentLauncher

namespace AudioOutput {

CHIP_ERROR CheckOutputTypeEnum(OutputTypeEnum val)
{
    switch (val)
    {
    case OutputTypeEnum::kHdmi:
    case OutputTypeEnum::kBt:
    case OutputTypeEnum::kOptical:
    case OutputTypeEnum::kHeadphone:
    case OutputTypeEnum::kInternal:
    case OutputTypeEnum::kOther:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace AudioOutput

namespace ApplicationLauncher {

CHIP_ERROR CheckApplicationLauncherStatusEnum(ApplicationLauncherStatusEnum val)
{
    switch (val)
    {
    case ApplicationLauncherStatusEnum::kSuccess:
    case ApplicationLauncherStatusEnum::kAppNotAvailable:
    case ApplicationLauncherStatusEnum::kSystemBusy:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace ApplicationLauncher

namespace ApplicationBasic {

CHIP_ERROR CheckApplicationStatusEnum(ApplicationStatusEnum val)
{
    switch (val)
    {
    case ApplicationStatusEnum::kStopped:
    case ApplicationStatusEnum::kActiveVisibleFocus:
    case ApplicationStatusEnum::kActiveHidden:
    case ApplicationStatusEnum::kActiveVisibleNotFocus:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace ApplicationBasic

namespace AccountLogin {
} // namespace AccountLogin

namespace Messaging {

CHIP_ERROR CheckEventId(EventId val)
{
    switch (val)
    {
    case EventId::kMeterCoverRemoved:
    case EventId::kMeterCoverClosed:
    case EventId::kStrongMagneticField:
    case EventId::kNoStrongMagneticField:
    case EventId::kBatteryFailure:
    case EventId::kLowBattery:
    case EventId::kProgramMemoryError:
    case EventId::kRamError:
    case EventId::kNvMemoryError:
    case EventId::kMeasurementSystemError:
    case EventId::kWatchdogError:
    case EventId::kSupplyDisconnectFailure:
    case EventId::kSupplyConnectFailure:
    case EventId::kMeasurmentSoftwareChanged:
    case EventId::kDstEnabled:
    case EventId::kDstDisabled:
    case EventId::kClockAdjBackward:
    case EventId::kClockAdjForward:
    case EventId::kClockInvalid:
    case EventId::kCommsErrorHan:
    case EventId::kCommsOkHan:
    case EventId::kFraudAttempt:
    case EventId::kPowerLoss:
    case EventId::kIncorrectProtocol:
    case EventId::kUnusualHanTraffic:
    case EventId::kUnexpectedClockChange:
    case EventId::kCommsUsingUnauthenticatedComponent:
    case EventId::kErrorRegClear:
    case EventId::kAlarmRegClear:
    case EventId::kUnexpectedHwReset:
    case EventId::kUnexpectedProgramExecution:
    case EventId::kEventLogCleared:
    case EventId::kManualDisconnect:
    case EventId::kManualConnect:
    case EventId::kRemoteDisconnection:
    case EventId::kLocalDisconnection:
    case EventId::kLimitThresholdExceeded:
    case EventId::kLimitThresholdOk:
    case EventId::kLimitThresholdChanged:
    case EventId::kMaximumDemandExceeded:
    case EventId::kProfileCleared:
    case EventId::kFirmwareReadyForActivation:
    case EventId::kFirmwareActivated:
    case EventId::kPatchFailure:
    case EventId::kTouTariffActivation:
    case EventId::k8x8Tariffactivated:
    case EventId::kSingleTariffRateActivated:
    case EventId::kAsynchronousBillingOccurred:
    case EventId::kSynchronousBillingOccurred:
    case EventId::kIncorrectPolarity:
    case EventId::kCurrentNoVoltage:
    case EventId::kUnderVoltage:
    case EventId::kOverVoltage:
    case EventId::kNormalVoltage:
    case EventId::kPfBelowThreshold:
    case EventId::kPfAboveThreshold:
    case EventId::kTerminalCoverRemoved:
    case EventId::kTerminalCoverClosed:
    case EventId::kReverseFlow:
    case EventId::kTiltTamper:
    case EventId::kBatteryCoverRemoved:
    case EventId::kBatteryCoverClosed:
    case EventId::kExcessFlow:
    case EventId::kCreditOk:
    case EventId::kLowCredit:
    case EventId::kEmergencyCreditInUse:
    case EventId::kEmergencyCreditExhausted:
    case EventId::kZeroCreditEcNotSelected:
    case EventId::kSupplyOn:
    case EventId::kSupplyOffAarmed:
    case EventId::kSupplyOff:
    case EventId::kDiscountApplied:
    case EventId::kManufacturerSpecificA:
    case EventId::kManufacturerSpecificB:
    case EventId::kManufacturerSpecificC:
    case EventId::kManufacturerSpecificD:
    case EventId::kManufacturerSpecificE:
    case EventId::kManufacturerSpecificF:
    case EventId::kManufacturerSpecificG:
    case EventId::kManufacturerSpecificH:
    case EventId::kManufacturerSpecificI:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckMessagingControlConfirmation(MessagingControlConfirmation val)
{
    switch (val)
    {
    case MessagingControlConfirmation::kNotRequired:
    case MessagingControlConfirmation::kRequired:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckMessagingControlEnhancedConfirmation(MessagingControlEnhancedConfirmation val)
{
    switch (val)
    {
    case MessagingControlEnhancedConfirmation::kNotRequired:
    case MessagingControlEnhancedConfirmation::kRequired:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckMessagingControlImportance(MessagingControlImportance val)
{
    switch (val)
    {
    case MessagingControlImportance::kLow:
    case MessagingControlImportance::kMedium:
    case MessagingControlImportance::kHigh:
    case MessagingControlImportance::kCritical:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}

CHIP_ERROR CheckMessagingControlTransmission(MessagingControlTransmission val)
{
    switch (val)
    {
    case MessagingControlTransmission::kNormal:
    case MessagingControlTransmission::kNormalAndAnonymous:
    case MessagingControlTransmission::kAnonymous:
    case MessagingControlTransmission::kReserved:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace Messaging

namespace ApplianceIdentification {
} // namespace ApplianceIdentification

namespace MeterIdentification {
} // namespace MeterIdentification

namespace ApplianceEventsAndAlert {

CHIP_ERROR CheckEventIdentification(EventIdentification val)
{
    switch (val)
    {
    case EventIdentification::kEndOfCycle:
    case EventIdentification::kTemperatureReached:
    case EventIdentification::kEndOfCooking:
    case EventIdentification::kSwitchingOff:
    case EventIdentification::kWrongData:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace ApplianceEventsAndAlert

namespace ApplianceStatistics {
} // namespace ApplianceStatistics

namespace ElectricalMeasurement {
} // namespace ElectricalMeasurement

namespace TestCluster {

CHIP_ERROR CheckSimpleEnum(SimpleEnum val)
{
    switch (val)
    {
    case SimpleEnum::kUnspecified:
    case SimpleEnum::kValueA:
    case SimpleEnum::kValueB:
    case SimpleEnum::kValueC:
        return CHIP_NO_ERROR;
    default:
        return CHIP_ERROR_UNKNOWN_ENUM_VALUE;
    }
}
} // namespace TestCluster

} // namespace Clusters
} // namespace app
} // namespace chip
